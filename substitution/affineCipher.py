#Affine Cipher encryption and decryption functions
#default alphabet is [A-Z]
#Change alphabet below if you want to use a custom alphabet
ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

c = '24435 38 9 115072 79850 5 80902 3492 29 3492 0 79850 332249 9 3492 58 7914 24435 441 332249 3421 7914 80902 2 3492 58 2108 441 7914 58 80902 3492 7914 38 9 115072 79850 5 80902 332249 3421 7914 441 441 332249 0 7914 80902 2 332249 80902 3492 5 7914 115072 332249 80902 7914 441 332249 80902 80902 2 7914 29 7914 10 7914 29 3492 7 3421 7914 332249 38 24435 38 0 80902 2 332249 80902 24435 441 857219 3492 115072 58 441 3492 115072 5 2 115072 332249 441 7914 441 332249 115072 7914 9 3492 38 10 7914 115072 80902 7914 58 24435 38 80902 3492 441 3492 3421 7914 80902 2 24435 38 0 7914 29 441 7914 332249 9 3492 58 7914 3421 24435 0 2 80902 80902 115072 332249 38 441 7 3492 115072 3421 9 2 332249 38 0 7914 24435 38 80902 3492 9 10 0 58 4197 3492 115072 9 3492 9 4197 80902 332249 24435 29 29 3492 2108 38 0 7914 80902 2 7914 2108 441 38 332249 80902 24435 3492 38 332249 29 441 7914 9 2108 115072 24435 80902 79850 332249 0 7914 38 9 79850 58 7914 7 24435 38 7914 58 332249 9 3492 58 7914 332249 441 332249 441 2108 41 441 80902 24435 80902 2108 80902 24435 3492 38 9 115072 79850 5 80902 3492 441 79850 441 80902 7914 3421 24435 38 857219 2 24435 9 2 80902 2 7914 5 29 332249 24435 38 80902 7914 558045 80902 7914 29 7914 3421 7914 38 80902 441 332249 115072 7914 5 115072 24435 3421 332249 115072 24435 29 79850 857219 3492 115072 58 441 5 2 115072 332249 441 7914 441 3492 115072 441 7914 38 80902 7914 38 9 7914 441 332249 38 58 80902 2 7914 9 3492 58 7914 7914 3 2108 24435 10 332249 29 7914 38 80902 441 9 332249 29 29 7914 58 9 3492 58 7914 0 115072 3492 2108 5 441 80902 79850 5 24435 9 332249 29 29 79850 9 3492 38 441 24435 441 80902 3492 7 29 7914 80902 80902 7914 115072 441 3492 115072 58 24435 0 24435 80902 441 3492 115072 41 3492 80902 2 24435 38 3492 80902 2 7914 115072 857219 24435 441 7914 3421 7914 332249 38 24435 38 0 29 7914 441 441 9 3492 3421 41 24435 38 332249 80902 24435 3492 38 441 3492 7 24435 58 7914 38 80902 24435 9 332249 29 29 7914 38 0 80902 2 332249 9 3492 58 7914 41 3492 3492 4197 24435 441 38 7914 7914 58 7914 58 80902 3492 7914 38 9 115072 79850 5 80902 332249 38 58 58 7914 9 115072 79850 5 80902 80902 2 7914 5 2 115072 332249 441 7914 441 3492 115072 857219 3492 115072 58 441 41 79850 9 3492 38 80902 115072 332249 441 80902 9 24435 5 2 7914 115072 441 7914 38 9 115072 79850 5 80902 3421 7914 441 441 332249 0 7914 441 332249 80902 80902 2 7914 29 7914 10 7914 29 3492 7 24435 38 58 24435 10 24435 58 2108 332249 29 29 7914 80902 80902 7914 115072 441 3492 115072 441 3421 332249 29 29 0 115072 3492 2108 5 441 3492 7 29 7914 80902 80902 7914 115072 441 3492 115072 7914 10 7914 38 24435 38 3421 3492 58 7914 115072 38 9 24435 5 2 7914 115072 441 24435 38 58 24435 10 24435 58 2108 332249 29 41 24435 80902 441 3421 7914 441 441 332249 0 7914 441 9 332249 38 41 7914 80902 115072 332249 38 441 7 3492 115072 3421 7914 58 7 24435 115072 441 80902 41 79850 332249 9 3492 58 7914 332249 38 58 80902 2 7914 38 41 79850 332249 9 24435 5 2 7914 115072 441 2108 9 2 3421 2108 29 80902 24435 5 29 7914 7914 38 9 115072 79850 5 80902 24435 3492 38 3492 115072 441 2108 5 7914 115072 7914 38 9 115072 79850 5 80902 24435 3492 38 332249 24435 3421 441 80902 3492 3421 332249 4197 7914 9 115072 79850 5 80902 332249 38 332249 29 79850 441 24435 441 3421 3492 115072 7914 58 24435 7 7 24435 9 2108 29 80902 24435 441 80902 3492 29 7914 80902 2 24435 441 9 24435 5 2 7914 115072 7 115072 3492 3421 441 3492 3421 7914 5 2108 38 4197 2 24435 0 2 441 9 2 3492 3492 29 7914 115072 441 7 115072 3492 3421 5 332249 29 3492 332249 29 80902 3492 9 332249 29 24435 7 3492 115072 38 24435 332249'
c = c.split()
r = []
for item in c:
    if item not in r:
        r.append(item)

res = []
for item in c:
    res.append(ALPHABET[r.index(item)])

print(''.join(res))

#encryption: C = (aP + b) % m where m = length of the alphabet
def encrypt(a, b, message, alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):

    ciphertext_list = [(alphabet[(a * (alphabet.find(message[i])) + b) % len(alphabet)]
                      if alphabet.find(message[i]) != -1 else message[i])
                      for i in range(len(message))]

    return ''.join(ciphertext_list)


# decryption: (C - b) * (a^(-1) mod m) where m = length of the alphabet
def decrypt(a, b, message, alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):

    ciphertext_list = [(alphabet[(((alphabet.find(message[i])) - b)
                        * inv_mod(a, len(alphabet))) % len(alphabet)]
                        if alphabet.find(message[i]) != -1 else message[i])
                       for i in range(len(message))]

    return ''.join(ciphertext_list)

#this inverse_modulo function was taken from the book "Cracking Codes with Python"
def inv_mod(a, m):
    # Return the modular inverse of a % m, which is
    # the number x such that a*x % m = 1

    if gcd(a, m) != 1:
        return None # No mod inverse exists if a & m aren't relatively prime.

    # Calculate using the Extended Euclidean Algorithm:
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3 # Note that // is the integer division operator
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

#gcd function also came from the book
def gcd(a, b):
    # Return the Greatest Common Divisor of a and b using Euclid's Algorithm
    while a != 0:
        a, b = b % a, a
    return b

def main():
    #PRECONDITION: message-case matches ALPHABET case (this is case-sensitive!)
    msg = input("Enter message: ")
    a = int(input("a = "))
    b = int(input("b = "))
    mode = input("Encrypt or decrypt <e/d>?: ")
    if gcd(a, len(ALPHABET)) != 1:
        raise ValueError("ERROR: 'a' is not coprime to the length of the alphabet")
    if mode.upper() == 'E':
        print(encrypt(a, b, msg, ALPHABET))
    elif mode.upper() == 'D':
        print(decrypt(a, b, msg, ALPHABET))
    else:
        raise ValueError("ERROR: invalid mode")


if __name__ == '__main__':
    main()





